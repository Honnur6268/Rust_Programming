// Generic: Generic data types are a way to define functions or structs that work with any type
// Generice functions can work with any type
// Define a generic function that can work with any type T
// Monomorphization is the process of turning generic code into specific code by filling in the type that is used when compiled code is generated by the compiler at compile time (not runtime).
// The compiler will generate code for each type that is used in the generic function.
pub fn generics_demo(){
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number from array: {:?} is {}", number_list, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);

    println!("The larger of 34 and 50 is {}", larger(34, 50));
    println!("The larger of a and b is {}", larger('a', 'b'));
}

fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn larger<T: std::cmp::PartialOrd>(a: T, b: T) -> T {
    if a > b {
        a
    } else {
        b
    }
}
